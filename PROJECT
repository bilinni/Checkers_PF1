;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname PROJECT) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))

;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;                                                                      COSTANTS AND STRUCTURES 

;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

(require 2htdp/image)
(require 2htdp/universe)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                             Structures   

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Data Type - Control
; We introduce the data type Turn, which represents a Posn of Numbers (where the numbers are between 0 and 7, both included), and also the data type Maybe<Turn>,
; which is one of:
;  - a Turn
;  - #false
;
; A Control is a structure (make-control start end):
;      where         start     : Maybe<Turn>
;                    end       : Maybe<Turn>
;
; Attention: start and end cannot be different, for example (make-control #false (make-posn 4 2)) is not defined! The possibilities are of the following form:
; - (make-control #false #false), or
; - (make-control (make-posn 4 5) (make-posn 5 4))
;
; interpretation: is meant to be eather moving a token from a starting position to an ending position, or not doing so 
(define-struct control [start end])


;; Data Types - Team
; A TeamName is one of the following Strings:
; - "W"
; - "B"
; which stand for `White` and `Black` 
;
; A team is a structure (make-team name image):
;      where         name      : TeamName 
;                    image     : Image
;
; interpretation: represents the team's turn     
(define-struct team [name image])



;; Data Type - Token
; A Token is a structure (make-token color super coordinates):
;             where         color          : Team      
;                           super          : Boolean 
;                           coordinates    : Posn ; the elements are integer positive Numbers between 0 and 7 as usual
;
; interpretation: is a token which is identified with it's color, it's attributes if it reaches the other side of the board (it's a `super` token if it is the case)
;                 and it's position on the board
(define-struct token [color super coordinates])

;; Data Type - List<Token>
; A List<Token> is one of the following:
; - '() ; base case: EmptyList
; recursive case: List with 1, 2, 3 ... elements
; - (cons Token List<Token>)

;: Data Type - Table
; A Table is a structure (make-table image tokens control player won?)
;    where          image          : Image
;                   tokens         : List<Token>
;                   move           : Control
;                   player         : Team
;                   won?           : Boolean
;
; interpretation: saves all the informations regarding the current state of the board,
;                 namely the number of tokens of both player, control for moving a token, player's turn and if there is a winner:
(define-struct table [image tokens move player won?])



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                    Board and Token Informations

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Black token
(define B-TOKEN (overlay
  (scale/xy 0.234375
            0.234375
   (bitmap "B-TOKEN.png")) (circle 42 "solid" "white")))

;; White token
(define W-TOKEN (overlay
  (scale/xy 0.234375
            0.234375
   (bitmap "W-TOKEN.png")) (circle 42 "solid" "white")))

;; Black super token
(define B-SUPER-TOKEN (overlay
  (scale/xy (/ 120 512)
            (/ 120 512)
   (bitmap "B-SUPER-TOKEN.png")) (circle 40 "solid" "white")))

;; White super token 
(define W-SUPER-TOKEN (overlay
  (scale/xy (/ 120 512)
            (/ 120 512)
   (bitmap "W-SUPER-TOKEN.png")) (circle 40 "solid" "white")))

;; White square
(define W-SQUARE
  (scale/xy 0.2
            0.2985074627
   (bitmap/url "https://i.pinimg.com/originals/01/13/f9/0113f94f11c47c63ce2221645121b863.jpg")))


;; Black square
(define B-SQUARE
  (scale/xy 0.1960784314
            0.2745995423
   (bitmap/url "https://media.istockphoto.com/id/953189548/photo/texture-wood.jpg?s=612x612&w=0&k=20&c=gpZ9d3OtFYaf3KmrR80_81Vq8Yf4aRVAlTO4u3GlnJQ=")))

;; Square size
(define SIZE 120)



;; Board
(define BOARD (above
              (beside W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE)
              
              (beside B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE)

              (beside W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE)
              
              (beside B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE)
              
              (beside W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE)
              
              (beside B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE)
              
              (beside W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE)
              
              (beside B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE B-SQUARE W-SQUARE)))    


;; Tokens list 
(define TOKENS-LIST (list
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 1 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 3 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 5 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 1 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 3 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 5 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 7 2))

                        (make-token (make-team "B" B-TOKEN) #false (make-posn 0 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 2 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 4 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 7 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 0 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 2 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 4 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 6 7))))

;; Initial state
(define INITIAL-STATE (make-table BOARD TOKENS-LIST (make-control #false #false) (make-team "W" W-TOKEN) #false))



;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;                                                                      MAIN FUNCTIONS OF THE GAME  

;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                 Recognition of the square by posn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need Posn as both as input and output

;; Input/Output
; get-id-by-position : Posn -> Posn
; returns the posn of the square with respect of the position of the mouse.
; header: (define (get-id-by-position pos) (make-posn 0 0))

;; Examples

(check-expect (get-id-by-position (make-posn 234.5 124.7)) (make-posn 1 1))
(check-expect (get-id-by-position (make-posn 653 253.2)) (make-posn 5 2))

;; Template

; (define (get-id-by-position pos)  
;   ... (posn-x pos) ... (posn-y pos) ...)

;; Code


(define (get-id-by-position pos)  
  (make-posn (floor (abs (/ (posn-x pos) SIZE))) (floor (abs (/ (posn-y pos) SIZE)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                              Add a token in the current token's list

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Table as input and type List<Token> as output 

;; Input/Output
; add-element : Table -> List<Token> 
; adds a new token in the current state and also in the token's list.
; If the token becoms a super token, we create a new token with a new image, otherwise we create a new token with the same image  
; header: (define (add-element state) state)

;; Examples

(check-expect (add-element (make-table BOARD TOKENS-LIST (make-control (make-posn 1 2) (make-posn 2 3)) (make-team "W" W-TOKEN) #false))
              (append TOKENS-LIST (list (make-token (make-team "W" W-TOKEN) #false (make-posn 2 3))))) 

(check-expect (add-element (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 7 6))
                                                   (make-token (make-team "B" B-TOKEN) #false (make-posn 0 1))) (make-control (make-posn 0 1) (make-posn 1 0)) (make-team "B" B-TOKEN) #false))
              (append
               (list (make-token (make-team "W" W-TOKEN) #false (make-posn 7 6))
                                                   (make-token (make-team "B" B-TOKEN) #false (make-posn 0 1)))
               (list (make-token (make-team "B" B-SUPER-TOKEN) #true (make-posn 1 0)))))

(check-expect (add-element (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 7 6))
                                                   (make-token (make-team "B" B-TOKEN) #false (make-posn 0 1))) (make-control (make-posn 7 6) (make-posn 6 7)) (make-team "W" W-TOKEN) #false))
              (append
               (list (make-token (make-team "W" W-TOKEN) #false (make-posn 7 6))
                                                   (make-token (make-team "B" B-TOKEN) #false (make-posn 0 1)))
               (list (make-token (make-team "W" W-SUPER-TOKEN) #true (make-posn 6 7)))))
                                                    
;; Template

; (define (add-element state)
;   (cond
;    [(and                                                                                                                      ; if the token is white and is going to be a super token, or it was so already, ...
;      (or (super? (control-end (table-move state)) (table-player state)) 
;             (not (false? (token-super (first (get-token-by-pos state (control-start (table-move state))))))))
;      (equal? (team-name (table-player state)) "W"))
;
;     ... (table-tokens state) ... (team-name (table-player state)) ... (team-image (table-player state)) ...    
;     ... (posn-x (control-end (table-move state))) ... (posn-y (control-end (table-move state))) ... (table-player state) ...]
;
;    [(and                                                                                                                      ; if the token is black and is going to be a super token, or it was so already, ...
;      (or (super? (control-end (table-move state)) (table-player state))                                       
;             (not (false? (token-super (first (get-token-by-pos state (control-start (table-move state))))))))
;      (equal? (team-name (table-player state)) "B"))
;
;     ... (table-tokens state) ... (team-name (table-player state)) ... (team-image (table-player state)) ...    
;     ... (posn-x (control-end (table-move state))) ... (posn-y (control-end (table-move state))) ... (table-player state) ...]
;
;    [else                                                                                                                      ; else, ...
;
;     ... (table-tokens state) ... (team-name (table-player state)) ... (team-image (table-player state)) ...    
;     ... (posn-x (control-end (table-move state))) ... (posn-y (control-end (table-move state))) ... (table-player state) ...]                                               
;      


;; Code

(define (add-element state)
  (cond
    [(and
      (or (super? (control-end (table-move state)) (table-player state)) 
             (not (false? (token-super (first (get-token-by-pos state (control-start (table-move state))))))))
      (equal? (team-name (table-player state)) "W"))
     (append
      (table-tokens state)
      (list (make-token (make-team (team-name (table-player state)) W-SUPER-TOKEN)
                        #true
                        (make-posn (posn-x (control-end (table-move state))) (posn-y (control-end (table-move state)))))))]

    [(and
      (or (super? (control-end (table-move state)) (table-player state)) 
             (not (false? (token-super (first (get-token-by-pos state (control-start (table-move state))))))))
      (equal? (team-name (table-player state)) "B"))
     (append
      (table-tokens state)
      (list (make-token (make-team (team-name (table-player state)) B-SUPER-TOKEN)
                        #true
                        (make-posn (posn-x (control-end (table-move state))) (posn-y (control-end (table-move state)))))))]

    [else
     (append
      (table-tokens state)
      (list (make-token (table-player state)
                        #false
                        (make-posn (posn-x (control-end (table-move state))) (posn-y (control-end (table-move state)))))))]))


   


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                             Remove token from the current token's list

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Table and Posn as input and type List<Token> as output 

;; Input/Output
; remove-element : Table Posn -> List<Token>  
; deletes a token from the state and returns the list of token without   
; header: (define (remove-element state pos) '())

;; Examples

(check-expect (remove-element (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 3 2))
                                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 5 2))
                                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 7 2))

                                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 0 5))
                                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 2 5))
                                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 4 5))) (make-control #false #false) (make-team "B" B-TOKEN) #false) (make-posn 0 5))

                              (list (make-token (make-team "W" W-TOKEN) #false (make-posn 3 2))
                                    (make-token (make-team "W" W-TOKEN) #false (make-posn 5 2))
                                    (make-token (make-team "W" W-TOKEN) #false (make-posn 7 2))

                                    (make-token (make-team "B" B-TOKEN) #false (make-posn 2 5))
                                    (make-token (make-team "B" B-TOKEN) #false (make-posn 4 5))))

(check-expect (remove-element (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 5 0))
                                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))

                                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))) (make-control #false #false) (make-team "W" W-TOKEN) #false) (make-posn 5 0))

                              (list (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                                    (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                    (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                    (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                    (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))

                                    (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                    (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                    (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                                    (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))))

;; Template

; (define (remove-element state pos)
;   (remove #false (map
;                   (lambda (item)
;                      ... (posn-x (token-coordinates item)) ... (posn-x pos) ... (posn-y (token-coordinates item)) ... (posn-y pos) ...
;                  ... (table-tokens state) ...)))

;; Code

(define (remove-element state pos)
  (remove #true (map
                  (lambda (item)
                    (if (and (= (posn-x (token-coordinates item)) (posn-x pos))
                             (= (posn-y (token-coordinates item)) (posn-y pos))) #true
                     item))
                 (table-tokens state))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                    Change token's position

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Table as both input and output 

;; Input/Output
; change-position : Table -> Table 
; changes the current state to a new state where a token has been moved. In order to work we need the auxiliary functions
; change-player (which changes the player's turn) and no-tokens (which checks if a team has lost all the tokens) 
; header: (define (change-position state) state)

;; Examples

(check-expect (change-position (make-table BOARD TOKENS-LIST (make-control (make-posn 0 5) (make-posn 1 4)) (make-team "B" B-TOKEN) #false))
                 (make-table BOARD (list
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 1 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 3 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 5 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 1 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 3 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 5 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 7 2))

                        
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 2 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 4 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 7 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 0 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 2 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 4 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 6 7))

                        (make-token (make-team "B" B-TOKEN) #false (make-posn 1 4))) (make-control #false #false) (make-team "W" W-TOKEN) #false)) ; new token in posn 1 4

(check-expect (change-position (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 5 0))
                                                       (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                                                       (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                                       (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                                       (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                                       (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))

                                                       (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                                       (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                                       (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                                                       (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))) (make-control (make-posn 6 1) (make-posn 5 2)) (make-team "W" W-TOKEN) #false))

              (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 5 0))
                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                      

                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                                      (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))

                                      (make-token (make-team "W" W-TOKEN) #false (make-posn 5 2))) (make-control #false #false) (make-team "B" B-TOKEN) #false))

              

;; Template

; (define (change-position state)
; ... (table-image state) ... (table-move state) ... (table-player state) ... (table-won? state) ... (control-start (table-move state)))

;; Code

(define (change-position state)
  (make-table
   (table-image state)
   (remove-element (make-table
                   (table-image state)
                   (add-element state)
                   (table-move state)
                   (table-player state)
                   (table-won? state)) (control-start (table-move state)))
   (make-control #false #false)
   (change-player state)
   (no-tokens state)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                          Filter tokens 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Table and Posn as input, and type List<Token> as output

;; Input/Output
; get-token-by-pos : Table Posn -> List<Token>
; finds the token whose coordinates coincide with a give posn
; header: (define (get-token-by-pos state pos) table)

;; Examples

(check-expect (get-token-by-pos INITIAL-STATE (make-posn 3 6)) (list (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))))
(check-expect (get-token-by-pos (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                                        (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                                        (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                                        (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))
                                                        (make-token (make-team "W" W-TOKEN) #false (make-posn 1 2))) (make-control #false #false) (make-team "B" B-TOKEN) #false ) (make-posn 23 1)) '())

;; Template

; (define (get-token-by-pos state pos) 
;   (filter
;    (lambda (item)
;      ... (posn-x pos) ... (posn-y pos) ... (token-coordinates item) ...)
;   ... (table-tokens state) ...))

;; Code

(define (get-token-by-pos state pos) 
  (filter
   (lambda (item)
    (and (= (posn-x (token-coordinates item)) (posn-x pos))
         (= (posn-y (token-coordinates item)) (posn-y pos))))
  (table-tokens state)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                           Move checker 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Table and Token as input, and Boolean as output

;; Input/Output
; allow-move? : Table List<Token> List<Token> -> Boolean
; checks if a move is valid or not.  
; header (define (allow-move? state token1 token2) #true)

;; Examples



;; Template

;(define (allow-move? state token1 token2)
;  (cond
;    [(= (length token1) 0) ... state token1 token2 ...]
;    [(not (string=? (team-name (table-player state)) (team-name (token-color (first token1))))) ... state token1 token2 ...]
;    [(not (= (length token2) 0)) ... state token1 token2 ...]
;    [(not
;      (or
;       (and (not (token-super (first token1)))
;            (string=? (team-name (token-color (first token1))) "W")
;            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state))))  1)
;            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 1))
;                  
;       (and (not (token-super (first token1)))
;            (string=? (team-name (token-color (first token1))) "B")
;            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state)))) -1)
;            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 1))
;                  
;       (and (token-super (first token1))
;            (equal? (posn-abs (posn-subtract (control-start (table-move state)) (control-end (table-move state)))) (make-posn 1 1))))) ... state token1 token2 ...]
;
;    [else ... state token1 token2 ...]))

;; Code

(define (allow-move? state token1 token2)
  (cond
    [(= (length token1) 0) #false]
    [(not (string=? (team-name (table-player state)) (team-name (token-color (first token1))))) #false]
    [(not (= (length token2) 0)) #false]
    [(not
      (or
       (and (not (token-super (first token1)))
            (string=? (team-name (token-color (first token1))) "W")
            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state))))  1)
            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 1))
                  
       (and (not (token-super (first token1)))
            (string=? (team-name (token-color (first token1))) "B")
            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state)))) -1)
            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 1))
                  
       (and (token-super (first token1))
            (equal? (posn-abs (posn-subtract (control-start (table-move state)) (control-end (table-move state)))) (make-posn 1 1))))) #false]

    [else #true]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                           Attack checker 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Table and Token as input, and Boolean as output

;; Input/Output
; allow-attack? : Table List<Token> List<Token> -> Boolean
; checks if an attack is valid or not 
; header (define (allow-attack? state token1 token2) #true)

;; Examples



;; Template

;(define (allow-attack? state token1 token2)
;  (cond
;    [(= (length token1) 0) ... state token1 token2 ...]
;    [(= (length (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))) 0) ... state token1 token2 ...]
;    [(not (string=? (team-name (table-player state)) (team-name (token-color (first token1))))) ... state token1 token2 ...]
;    [(not (= (length token2) 0)) ... state token1 token2 ...]
;    [(not
;      (or
;       (and (not (token-super (first token1)))
;            (string=? (team-name (token-color (first token1))) "W")
;            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state))))  2)
;            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 2)
;            (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))))) (invert-team (team-name (token-color (first token1))))))
;                  
;       (and (not (token-super (first token1)))
;            (string=? (team-name (token-color (first token1))) "B")
;            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state)))) -2)
;            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 2)
;            (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))))) (invert-team (team-name (token-color (first token1))))))
;                  
;       (and (token-super (first token1))
;            (equal? (posn-abs (posn-subtract (control-start (table-move state)) (control-end (table-move state)))) (make-posn 2 2))
;            (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))))) (invert-team (team-name (token-color (first token1)))))))) ... state token1 token2 ...]
;    [else ... state token1 token2 ...]))

;; Code

(define (allow-attack? state token1 token2)
  (cond
    [(= (length token1) 0) #false]
    [(= (length (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))) 0) #false]
    [(not (string=? (team-name (table-player state)) (team-name (token-color (first token1))))) #false]
    [(not (= (length token2) 0)) #false]
    [(not
      (or
       (and (not (token-super (first token1)))
            (string=? (team-name (token-color (first token1))) "W")
            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state))))  2)
            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 2)
            (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))))) (invert-team (team-name (token-color (first token1))))))
                  
       (and (not (token-super (first token1)))
            (string=? (team-name (token-color (first token1))) "B")
            (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state)))) -2)
            (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 2)
            (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))))) (invert-team (team-name (token-color (first token1))))))
                  
       (and (token-super (first token1))
            (equal? (posn-abs (posn-subtract (control-start (table-move state)) (control-end (table-move state)))) (make-posn 2 2))
            (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))))) (invert-team (team-name (token-color (first token1)))))))) #false]
    [else #true]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                               Find middle token (Auxiliary function) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 

;; Data Type
; We need type Posn as both input and output

;; Input/Output
; find-middle : Posn Posn -> Posn
; returns the posn which is located between two posns (these are diagonally located)    
; header: (define (find-middle pos1 pos2) pos1) 

;; Examples

(check-expect (find-middle (make-posn 1 2) (make-posn 3 4)) (make-posn 2 3))
(check-expect (find-middle (make-posn 4 3) (make-posn 2 1)) (make-posn 3 2))

;; Template

; (define (find-middle start-pos end-pos)  
;   ... (posn-x pos1) ... (posn-y pos1) ... (posn-x pos2) ... (posn-y pos2) ...)

;; Code

(define (find-middle pos1 pos2)  
  (make-posn (+ (posn-x pos1) (/ (- (posn-x pos2) (posn-x pos1)) 2))
             (+ (posn-y pos1) (/ (- (posn-y pos2) (posn-y pos1)) 2))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                               Subtract posn's (Auxiliary function) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Posn as both input and output

;; Input/Output
; posn-subtract : Posn Posn -> Posn
; returns the difference between the first input and the second one  
; header: (define (posn-subtract pos1 pos2) pos1) 

;; Examples

(check-expect (posn-subtract (make-posn 5 6) (make-posn 2 2)) (make-posn 3 4))
(check-expect (posn-subtract (make-posn 7 2) (make-posn 4 1)) (make-posn 3 1))

;; Template

; (define (posn-subtract pos1 pos2)
;   ... (posn-x pos1) ... (posn-y pos1) ... (posn-x pos2) ... (posn-y pos2) ...) 

;; Code

(define (posn-subtract pos1 pos2)
  (make-posn (- (posn-x pos1) (posn-x pos2))
             (- (posn-y pos1) (posn-y pos2))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                               Coordinates in absolute value (Auxiliary function) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Posn as both input and output

;; Input/Output
; posn-abs : Posn -> Posn
; returns a posn with all the coordinates in absolute value of an input 
; header: (define (posn-abs pos) pos)

;; Examples

(check-expect (posn-abs (make-posn 3 -2)) (make-posn 3 2))
(check-expect (posn-abs (make-posn -2 5)) (make-posn 2 5))

;; Template

; (define (posn-abs pos)
;   ... posn-x pos ... posn-y pos ...)

;; Code

(define (posn-abs pos)
  (make-posn (abs (posn-x pos)) (abs (posn-y pos))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                               Team inversion 1 (Auxiliary function) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type String as both input and output

;; Input/Output
; change-player : String -> Team
; switches into "B" team if input was "W" team and "W" if it was "B" team
; header: (define (invert-team player) "B")

;; Tests

(check-expect (change-player INITIAL-STATE) (make-team "B" B-TOKEN))
(check-expect (change-player (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))

                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 7 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 0 7))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 2 7)))

                                                (make-control #false #false) (make-team "B" B-TOKEN) #false)) (make-team "W" W-TOKEN)) 

;; Template

; (define (change-player state) 
;   (cond
;     [(string=? (team-name (table-player state)) "W") (make-team "B" B-TOKEN)]
;     [else (make-team "W" W-TOKEN)]))

;; Code

(define (change-player state) 
  (cond
    [(string=? (team-name (table-player state)) "W") (make-team "B" B-TOKEN)]
    [else (make-team "W" W-TOKEN)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                               Team inversion 2 (Auxiliary function) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Data Type
; We need type String as both input and output

;; Input/Output
; invert-team : String -> String
; switches into "B" team if input was "W" team and "W" if it was "B" team
; header: (define (invert-team player) "B")

;; Tests

(check-expect (invert-team "W") "B")
(check-expect (invert-team "B") "W")

;; Template

; (define (invert-team player)
;   (cond
;     [(string=? player "W") ... player ...]
;     [else ... player ...]))

;; Code

(define (invert-team player)
  (cond
    [(string=? player "W") "B"]
    [else "W"]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                  Super checker (Auxiliary function) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Posn and Team as input and Boolean as output

;; Input/Output
; super? : Posn Team -> Boolean
; checks if a token has reached the other side of the board
; header: (define (super? pos team) #true)

;; Tests

(check-expect (super? (make-posn 4 7) (make-team "W" W-TOKEN)) #true)
(check-expect (super? (make-posn 1 0) (make-team "B" B-TOKEN)) #true)
(check-expect (super? (make-posn 2 3) (make-team "W" W-TOKEN)) #false)
(check-expect (super? (make-posn 5 4) (make-team "B" W-TOKEN)) #false)

;; Template

; (define (super? pos team) 
;  ... (posn-y pos) ... (team-name team) ...)

;; Code


(define (super? pos team) 
  (if
   (or (and (= (posn-y pos) 7) (string=? (team-name team) "W"))
       (and (= (posn-y pos) 0) (string=? (team-name team) "B"))) #true
  #false))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                      No-tokens checker (Auxiliary function for change-position) 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need Table ad Boolean

;; Input/Output
; no-tokens : Table -> Boolean
; checks if eather one team or the other has lost all the tokens
; header: (define (no-tokens state) state)

;; Tests

(check-expect (no-tokens INITIAL-STATE) #false)
(check-expect (no-tokens (make-table BOARD (list (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                                 (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                                 (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))) (make-control #false #false) (make-team "W" W-TOKEN) #true)) #true) 

;; Template

; (define (no-tokens state)
;   (if
;    (or
;     (= (length
;               (filter
;                (lambda (item)
;                 ... (team-name item) ... (token-color item)...)
;                ... (table-tokens state) ... )) 0)
;     (= (length
;               (filter
;                (lambda (item)
;                 ... (team-name item) ... (token-color item)...)
;                ... (table-tokens state) ... )) 0)) ... state ...
;    ... state ...))

;; Code

(define (no-tokens state)
  (if
   (or
    (= (length
              (filter
               (lambda (item)
                (string=? (team-name (token-color item)) "W")) 
               (table-tokens state))) 0)
    (= (length
              (filter
               (lambda (item)
                (string=? (team-name (token-color item)) "B"))
               (table-tokens state))) 0)) #true
   #false))


;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;                                                                        BIG BANG FUNCTIONS 

;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                        Rendering function 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; The input is type Table and the output is an Image

; Input/Output
; draw: Table -> Image
; takes a Table and returns an Image of the board with the currently tokens 
; header: (define (draw state) Image)

;; Examples



;; Template

; (define (draw state)
;   (local (; draw-tokens : Image List<Token> -> Image
;           ; draws the tokens on the board
;           (define (draw-tokens img token-list)
;             (cond
;               [(null? token-list) ... img ...]
;               [else (draw-tokens (overlay/xy (team-image (token-color (first token-list))) (* -1 (* SIZE (posn-x (token-coordinates (first token-list)))))
;                       (* -1 (* SIZE (posn-y (token-coordinates (first token-list))))) img) (rest token-list))])))  
;   (draw-tokens (table-image state) (table-tokens state))))

;; Code

(define (draw state)
  (local (; draw-tokens : Image List<Token> -> Image
          ; draws the tokens on the board
          (define (draw-tokens img token-list)
            (cond
              [(null? token-list) img]
              [else (draw-tokens (overlay/xy (team-image (token-color (first token-list))) (* -1 (* SIZE (posn-x (token-coordinates (first token-list)))))
                      (* -1 (* SIZE (posn-y (token-coordinates (first token-list))))) img) (rest token-list))])))  
  (draw-tokens (table-image state) (table-tokens state))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                           Mouse handler

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We introduce the data type MouseEvent, which represents one of the following Strings:
;                "botton-down"    : select one token to move
;                "drag"           : move the current token to the new position
;                "botton-up"      : add the current line to the canvas
; Other types that we need are Table and Number

;; Input/output
; handle-mouse: Table Number Number MouseEvent -> Table
; handles mouse events, that is, it updates the state according to the inputâ€™s MouseEvent
; header: (define (handle-mouse state x y event) event)

;; Examples



;; Template

; (define (handle-mouse state x y event)
;   (cond
;     [(string=? "button-down" event) ... (table-image state) ... (table-tokens state) ... (table-player state) ... (table-won?) ... x y ...]
;     [(and (string=? "drag" event) (not (false? (control-start (table-move state)))))
;      ... (table-image state) ... (table-tokens state) ... (control-start (table-move state)) ... (table-player state) ... (table-won?) ... x y ...]
;     [(and (string=? "button-up" event) (not (false? (control-start (table-move state)))))
;      (cond
;        [(allow-move? state (get-token-by-pos state (control-start (table-move state)))
;                      (get-token-by-pos state (control-end (table-move state)))) ... state x y event ...]
;        [(allow-attack? state (get-token-by-pos state (control-start (table-move state)))
;                      (get-token-by-pos state (control-end (table-move state))))
;          ... (table-image state) ... (control-start (table-move state)) ... (control-end (table-move state)) ... (control-start (table-move state)) ... x y ...] 
;        [else ... state x y event ...])]
;     [else ... state x y event ...]))


;; Code
(define (handle-mouse state x y event)
  (cond
    [(string=? "button-down" event)
     (make-table 
      (table-image state)
      (table-tokens state)
      (make-control (get-id-by-position (make-posn x y)) (get-id-by-position (make-posn x y)))
      (table-player state)
      (table-won? state))]
    [(and (string=? "drag" event) (not (false? (control-start (table-move state)))))
     (make-table 
      (table-image state)
      (table-tokens state)
      (make-control (control-start (table-move state)) (get-id-by-position (make-posn x y)))
      (table-player state)
      (table-won? state))]
   
    [(and (string=? "button-up" event) (not (false? (control-start (table-move state)))))
     (cond
       [(allow-move? state (get-token-by-pos state (control-start (table-move state)))
                     (get-token-by-pos state (control-end (table-move state)))) (change-position state)]
       [(allow-attack? state (get-token-by-pos state (control-start (table-move state)))
                     (get-token-by-pos state (control-end (table-move state))))
        (make-table
         (table-image state)
         (remove-element (change-position state) (find-middle (control-start (table-move state)) (control-end (table-move state))))
         (make-control (control-start (table-move state)) (get-id-by-position (make-posn x y)))
         (change-player state)
         (no-tokens state))]
       [else state])]
    [else state]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;                                                                          Winner checker 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need type Table as input and type Boolean as output

;; Input/Output
; win? : Table -> Boolean
; checks if there is a winner in the game 
; header (define (win? state) #true)


;; Examples

(check-expect (win? (make-table BOARD (list (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))) (make-control #false #false) (make-team "W" W-TOKEN) #true)) #true)

(check-expect (win? (make-table BOARD (list (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))

                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))) (make-control #false #false) (make-team "B" B-TOKEN) #false)) #false)


;; Template

;(define (win? state)
;  (if (table-won? state) ... state ...)
;    ... state ...)

;; Code

(define (win? state)
  (if (table-won? state) #true
      #false))


;;; MAIN FUNCTION

;; Data Type

;; Input/Output

(big-bang INITIAL-STATE
  [to-draw draw]
  [on-mouse handle-mouse]
;  [on-key handle-key]
  [stop-when win?]
  )

;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname PROJECT) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))

;///////////////////////////////
;;;; COSTANTS AND STRUCTURES 
;///////////////////////////////

(require 2htdp/image)
(require 2htdp/universe)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; BOARD AND TOKEN INFORMATIONS ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Square size
(define SIZE 50)

;; White Token
(define W-TOKEN 
   (circle (/ SIZE 2) "solid" "gray"))

;; Black Token
(define B-TOKEN
   (circle (/ SIZE 2) "solid" "red"))

(define B-TOKEN-SUPER
   (overlay (circle (/ SIZE 2) "outline" "gold") B-TOKEN))

(define W-TOKEN-SUPER
   (overlay (circle (/ SIZE 2) "outline" "gold") W-TOKEN))

;; Border board
(define BORDER (square (+(* SIZE 8)(* (* SIZE 8) (/ 1 26.67 )))"solid" "brown"))

;; Board
(define BOARD (above
              (beside (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black"))
              
              (beside (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white"))

              (beside (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black"))
              
              (beside (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white"))
              
              (beside (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black"))
              
              (beside (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white"))
              
              (beside (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black"))
              
              (beside (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white") (square SIZE "solid" "black") (square SIZE "solid" "white"))))


;; Complete board
(define C-BOARD (overlay BOARD BORDER))    

;;;;;;;;;;;;;;;;;;
;;; STRUCTURES ;;;
;;;;;;;;;;;;;;;;;;

;; Data Type - Control
; A Control is a structure (make-control start end):
;      where         start      : Boolean
;                    end        : Boolean
;
; interpretation: ? 
(define-struct control [start end])



;; Data Types - Team
; A team is a structure (make-team name image):
;      where         name      : is one of the Strings "W" or "B" which stands for `White` and `Black`
;                    image     : Image
;
; interpretation: ?    
(define-struct team [name image])



;; Data Type - Token
; A Token is a structure (make-token color super coordinates):
;             where         color          : Team      
;                           super          : Boolean 
;                           coordinates    : Posn ; the elements are integer positive Numbers between 0 and 7 (both included)
;
; interpretation: is a token which is identified with it's color, it's attributes if it reaches the other side of the board (it's a `super` token if it is the case)
;                 and it's position on the board
(define-struct token [color super coordinates])



;: Data Type - Table
; A Table is a structure (make-table Image Tokens Control Player won?)
;    where          image          : Image
;                   tokens         : List<Token>
;                   move           : Control
;                   player         : Team
;                   won?           : Boolean
;
; interpretation: Table saves all the informations regarding the current state of the board,
;                 namely the number of tokens of both player, control for moving a token, player's turn and if there is a winner:
(define-struct table [image tokens move player won?])


;; Tokens list 
(define TOKENS-LIST (list
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 1 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 3 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 5 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 1 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 3 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 5 2))
                        (make-token (make-team "W" W-TOKEN) #false (make-posn 7 2))

                        (make-token (make-team "B" B-TOKEN) #false (make-posn 0 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 2 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 4 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 7 6))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 0 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 2 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 4 7))
                        (make-token (make-team "B" B-TOKEN) #false (make-posn 6 7))
                        ))

;; Initital state
(define INITIAL-STATE (make-table BOARD TOKENS-LIST (make-control #false #false) (make-team "W" W-TOKEN) #false))

;///////////////////////////////////
;;;; MAIN FUNCTIONS OF THE GAME 
;///////////////////////////////////

;;; RECOGNITION OF THE SQUARE BY THE POSN

;; Data Type
; We need Posn as both as input and output

;; Input/Output
; get-id-by-position : Posn -> Posn
; returns the posn of the square with respect of the position of the mouse
; header: (define (get-id-by-position pos) (make-posn 0 0))

;; Examples

;; Template

;; Code

(define (get-id-by-position pos) ; return id of square by position of mouse 
  (make-posn (floor (- (abs (/ (posn-x pos) SIZE)) 0.4)) (floor (- (abs (/ (posn-y pos) SIZE)) 0.4)))) ; Uncalibrated version, to test the rest of the functionality

;;; 

(define (change-position state) ; delete token from start pos and add it on end pos
  (make-table
   (table-image state)
   (remove-element (make-table
                 (table-image state)
                 (add-element state)
                 (table-move state)
                 (table-player state)
                 (table-won? state)) (control-start (table-move state)))
   (make-control #false #false)
   (change-player state)
   (no-tokens state)))

;;; 

(define (remove-element state pos) ; state and posn of token we want delete
  (remove #false (map (lambda (item) ; ?
         (if (and (= (posn-x (token-coordinates item)) (posn-x pos))
                  (= (posn-y (token-coordinates item)) (posn-y pos))) #false item))
         (table-tokens state))))

(define (add-element state)
  (if (or (super? (control-end (table-move state)) (table-player state))
          (not (false? (token-super (first (get-token-by-pos state (control-start (table-move state))))))))
      (append (table-tokens state) (list (make-token
                                          (make-team (team-name (table-player state)) (overlay (circle (/ SIZE 2) "outline" "gold") (team-image (table-player state))))
                                          #true
                                          (make-posn (posn-x (control-end (table-move state)))
                                                     (posn-y (control-end (table-move state)))))))

      (append (table-tokens state) (list (make-token
                                          (table-player state)
                                          #false
                                          (make-posn (posn-x (control-end (table-move state)))
                                                     (posn-y (control-end (table-move state)))))))))
      
 


;; Movement checker


(define (get-token-by-pos state pos) ; Return list<token> or empty list
  (filter
   (lambda (item)
    (and (= (posn-x (token-coordinates item)) (posn-x pos))
         (= (posn-y (token-coordinates item)) (posn-y pos))))
  (table-tokens state)))






(define (allow-move? state start-token end-token)    
    (cond
           [(= (length start-token) 0) #false]
           [(not (string=? (team-name (table-player state)) (team-name (token-color (first start-token))))) #false]
           [(not (= (length end-token) 0)) #false]
           [(not (or
                  (and (not (token-super (first start-token)))
                       (string=? (team-name (token-color (first start-token))) "W")
                       (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state))))  1)
                       (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 1))
                  
                  (and (not (token-super (first start-token)))
                       (string=? (team-name (token-color (first start-token))) "B")
                       (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state)))) -1)
                       (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 1))
                  
                  (and (token-super (first start-token))
                       (equal? (posn-abs (posn-subtract (control-start (table-move state))
                                                             (control-end (table-move state)))) (make-posn 1 1))))) #false]
           [else #true]))



(define (allow-attack? state start-token end-token)    
    (cond
           [(= (length start-token) 0) #false]
           [(= (length (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state))))) 0) #false]
           [(not (string=? (team-name (table-player state)) (team-name (token-color (first start-token))))) #false]
           [(not (= (length end-token) 0)) #false]
           [(not (or
                  (and (not (token-super (first start-token)))
                       (string=? (team-name (token-color (first start-token))) "W")
                       (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state))))  2)
                       (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 2)
                       (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state)))))))
                                 (invert-team (team-name (token-color (first start-token))))))
                  
                  (and (not (token-super (first start-token)))
                       (string=? (team-name (token-color (first start-token))) "B")
                       (= (- (posn-y (control-end (table-move state))) (posn-y (control-start (table-move state)))) -2)
                       (= (abs (- (posn-x (control-end (table-move state))) (posn-x (control-start (table-move state))))) 2)
                       (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state)))))))
                                 (invert-team (team-name (token-color (first start-token))))))
                  
                  (and (token-super (first start-token))
                       (equal? (posn-abs (posn-subtract (control-start (table-move state))
                                                             (control-end (table-move state)))) (make-posn 2 2))
                       (string=? (team-name (token-color (first (get-token-by-pos state (find-middle (control-start (table-move state)) (control-end (table-move state)))))))
                                 (invert-team (team-name (token-color (first start-token)))))))) #false]
           [else #true]))



;;; FIND MIDDLE TOKEN FUNCTION 

;; Data Type
; We need type Posn as both input and output

;; Input/Output
; find-middle : Posn Posn -> Posn
; returns the posn which is located between two posns (these are diagonally located)    
; header: (define (find-middle pos1 pos2) pos1) 

;; Examples

(check-expect (find-middle (make-posn 1 2) (make-posn 3 4)) (make-posn 2 3))
(check-expect (find-middle (make-posn 4 3) (make-posn 2 1)) (make-posn 3 2))

;; Template

; (define (find-middle start-pos end-pos)  
;   ... (posn-x pos1) ... (posn-y pos1) ... (posn-x pos2) ... (posn-y pos2) ...)

;; Code

(define (find-middle pos1 pos2)  
  (make-posn (+ (posn-x pos1) (/ (- (posn-x pos2) (posn-x pos1)) 2))
             (+ (posn-y pos1) (/ (- (posn-y pos2) (posn-y pos1)) 2))))



;;; SUBTRACT POSNS FUNCTION

;; Data Type
; We need type Posn as both input and output

;; Input/Output
; posn-subtract : Posn Posn -> Posn
; returns the difference between the first input and the second one  
; header: (define (posn-subtract pos1 pos2) pos1) 

;; Examples

(check-expect (posn-subtract (make-posn 5 6) (make-posn 2 2)) (make-posn 3 4))
(check-expect (posn-subtract (make-posn 7 2) (make-posn 4 1)) (make-posn 3 1))

;; Template

; (define (posn-subtract pos1 pos2)
;   ... (posn-x pos1) ... (posn-y pos1) ... (posn-x pos2) ... (posn-y pos2) ...) 

;; Code

(define (posn-subtract pos1 pos2)
  (make-posn (- (posn-x pos1) (posn-x pos2))
             (- (posn-y pos1) (posn-y pos2))))


;;; COORDINATES IN ABSOLUTE VALUE

;; Data Type
; We need type Posn as both input and output

;; Input/Output
; posn-abs : Posn -> Posn
; returns a posn with all the coordinates in absolute value of an input 
; header: (define (posn-abs pos) pos)

;; Examples

(check-expect (posn-abs (make-posn 3 -2)) (make-posn 3 2))
(check-expect (posn-abs (make-posn -2 5)) (make-posn 2 5))

;; Template

; (define (posn-abs pos)
;   ... posn-x pos ... posn-y pos ...)

;; Code

(define (posn-abs pos)
  (make-posn (abs (posn-x pos)) (abs (posn-y pos))))

;;; TEAM INVERSION FUNCTION 1

;; Data Type
; We need type String as both input and output

;; Input/Output
; change-player : String -> Team
; switches into "B" team if input was "W" team and "W" if it was "B" team
; header: (define (invert-team player) "B")

;; Tests

(check-expect (change-player INITIAL-STATE) (make-team "B" B-TOKEN))
(check-expect (change-player (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 7 0))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                                     (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))

                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 5 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 7 6))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 0 7))
                                                     (make-token (make-team "B" B-TOKEN) #false (make-posn 2 7)))

                                         (make-control #false #false) (make-team "B" B-TOKEN) #false)) (make-team "W" W-TOKEN)) 

;; Template

; (define (change-player state) 
;   (cond
;     [(string=? (team-name (table-player state)) "W") (make-team "B" B-TOKEN)]
;     [else (make-team "W" W-TOKEN)]))

;; Code

(define (change-player state) 
  (cond
    [(string=? (team-name (table-player state)) "W") (make-team "B" B-TOKEN)]
    [else (make-team "W" W-TOKEN)]))


;;; TEAM INVERSION FUNCTION 2

;; Data Type
; We need type String as both input and output

;; Input/Output
; invert-team : String -> String
; switches into "B" team if input was "W" team and "W" if it was "B" team
; header: (define (invert-team player) "B")

;; Tests

(check-expect (invert-team "W") "B")
(check-expect (invert-team "B") "W")

;; Template

; (define (invert-team player)
;   (cond
;     [(string=? player "W") ... player ...]
;     [else ... player ...]))

;; Code

(define (invert-team player)
  (cond
    [(string=? player "W") "B"]
    [else "W"]))


;;; SUPER CHECKER 

;; Data Type
; We need type Posn and Team as input and Boolean as output

;; Input/Output
; super? : Posn Team -> Boolean
; checks if a token has reached the other side of the board
; header: (define (super? pos team) #true)

;; Tests

(check-expect (super? (make-posn 4 7) (make-team "W" W-TOKEN)) #true)
(check-expect (super? (make-posn 1 0) (make-team "B" B-TOKEN)) #true)
(check-expect (super? (make-posn 2 3) (make-team "W" W-TOKEN)) #false)
(check-expect (super? (make-posn 5 4) (make-team "B" W-TOKEN)) #false)

;; Template

; (define (super? pos team) 
;  ... (posn-y pos) ... (team-name team) ...)

;; Code


(define (super? pos team) 
  (if
   (or (and (= (posn-y pos) 7) (string=? (team-name team) "W"))
       (and (= (posn-y pos) 0) (string=? (team-name team) "B"))) #true
  #false))



;;; NO-TOKENS CHECKER

;; Data Type
; We need Table ad Boolean

;; Input/Output
; no-tokens : Table -> Boolean
; checks if eather one team or the other has lost all the tokens
; header: (define (no-tokens state) state)

;; Tests

(check-expect (no-tokens INITIAL-STATE) #false)
(check-expect (no-tokens (make-table BOARD (list (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                                 (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                                 (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))) (make-control #false #false) (make-team "W" W-TOKEN) #true)) #true) 

;; Template

; (define (no-tokens state)
;   (if
;    (or
;     (= (length
;               (filter
;                (lambda (item)
;                 ... (team-name item) ... (token-color item)...)
;                ... (table-tokens state) ... )) 0)
;     (= (length
;               (filter
;                (lambda (item)
;                 ... (team-name item) ... (token-color item)...)
;                ... (table-tokens state) ... )) 0)) ... state ...
;    ... state ...))

;; Code

(define (no-tokens state)
  (if
   (or
    (= (length
              (filter
               (lambda (item)
                (string=? (team-name (token-color item)) "W")) 
               (table-tokens state))) 0)
    (= (length
              (filter
               (lambda (item)
                (string=? (team-name (token-color item)) "B"))
               (table-tokens state))) 0)) #true
   #false))

;/////////////////////////
;;;; BIG BANG FUNCTIONS 
;/////////////////////////


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; RENDERING FUNCTION ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Data Type
; The input is type Table and the output is an Image

; Input/Output
; draw: Table -> Image
; takes a Table and returns an Image of the board with the currently tokens 
; header: (define (draw state) Image)

;; Examples

;(check-expect (draw (make-table BOARD (list (make-token (make-team "W" W-TOKEN) #false (make-posn 5 0))
;                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 1 2))
;                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
;                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))) (make-control #false #false) (make-team "W" W-TOKEN) #false))
;              )


;; Template

; (define (draw state)
;   (local (; draw-tokens : Image List<Token> -> Image
;           ; draws the tokens on the board
;           (define (draw-tokens img token-list)
;             (cond
;               [(null? token-list) ... img ...]
;               [else (draw-tokens (overlay/xy (team-image (token-color (first token-list))) (* -1 (* SIZE (posn-x (token-coordinates (first token-list)))))
;                       (* -1 (* SIZE (posn-y (token-coordinates (first token-list))))) img) (rest token-list))])))  
;   (draw-tokens (table-image state) (table-tokens state))))

;; Code

(define (draw state)
  (local (; draw-tokens : Image List<Token> -> Image
          ; draws the tokens on the board
          (define (draw-tokens img token-list)
            (cond
              [(null? token-list) img]
              [else (draw-tokens (overlay/xy (team-image (token-color (first token-list))) (* -1 (* SIZE (posn-x (token-coordinates (first token-list)))))
                      (* -1 (* SIZE (posn-y (token-coordinates (first token-list))))) img) (rest token-list))])))  
  (draw-tokens (table-image state) (table-tokens state))))



;;;;;;;;;;;;;;;;;;;;;
;;; MOUSE HANDLER ;;;  
;;;;;;;;;;;;;;;;;;;;;


;; Data Type
; We need a Table, two Numbers and a String as input, and a Table as output
; We introduce also type MouseEvent, which represents one of the following Strings:
;                "botton-down"    : start drawing a line
;                "drag"           : move the current line's end point
;                "botton-up"      : add the current line to the canvas

;; Input/output
; handle-mouse: Table Number Number MouseEvent -> Table
; handles mouse events, that is, it updates the state according to the input’s MouseEvent
; header: (define (handle-mouse state x y event) event)

;; Examples

; (check-expect (handle-mouse (make-AppState CANVAS g #f) 5 2 "button-down") (make-AppState CANVAS (make-Line (make-posn 5 2) (make-posn 0 0)) #f))
; (check-expect (handle-mouse (make-AppState CANVAS (make-Line (make-posn 3 1) (make-posn 1 1)) #f) 5 6 "drag") (make-AppState CANVAS (make-Line (make-posn 3 1) (make-posn 5 6)) #false))



;; Template

; (define (handle-mouse state x y event)
;   (cond
;     [(string=? "button-down" event) ... state x y event ...]
;     [(and (string=? "drag" event) (not (false? (control-start (table-move state)))))
;      ... state x y event ...]
;     [(and (string=? "button-up" event) (not (false? (control-start (table-move state)))))
;      ... state x y event ...]
;     [else ... state x y event ...]))


;; Code
(define (handle-mouse state x y event)
  (cond
    [(string=? "button-down" event)
     (make-table 
      (table-image state)
      (table-tokens state)
      (make-control (get-id-by-position (make-posn x y)) (get-id-by-position (make-posn x y)))
      (table-player state)
      (table-won? state))]
    [(and (string=? "drag" event) (not (false? (control-start (table-move state)))))
     (make-table 
      (table-image state)
      (table-tokens state)
      (make-control (control-start (table-move state)) (get-id-by-position (make-posn x y)))
      (table-player state)
      (table-won? state))]
   
    [(and (string=? "button-up" event) (not (false? (control-start (table-move state)))))
     (cond
       [(allow-move? state (get-token-by-pos state (control-start (table-move state)))
                     (get-token-by-pos state (control-end (table-move state)))) (change-position state)]
       [(allow-attack? state (get-token-by-pos state (control-start (table-move state)))
                     (get-token-by-pos state (control-end (table-move state))))
        (make-table
         (table-image state)
        (remove-element (change-position state) (find-middle (control-start (table-move state)) (control-end (table-move state))))
        (make-control (control-start (table-move state)) (get-id-by-position (make-posn x y)))
        (change-player state)
        (no-tokens state))]
       [else state])]
    [else state]))


;;; WINNER CHECKER

;; Data Type
; We need type Table as input and type Boolean as output

;; Input/Output
; win? : Table -> Boolean
; checks if there is a winner in the game 
; header (define (win? state) #true)


;; Examples

(check-expect (win? (make-table BOARD (list (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))) (make-control #false #false) (make-team "W" W-TOKEN) #true)) #true)

(check-expect (win? (make-table BOARD (list (make-token (make-team "B" B-TOKEN) #false (make-posn 6 5))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 1 6))
                                            (make-token (make-team "B" B-TOKEN) #false (make-posn 3 6))

                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 0 1))
                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 2 1))
                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 4 1))
                                            (make-token (make-team "W" W-TOKEN) #false (make-posn 6 1))) (make-control #false #false) (make-team "B" B-TOKEN) #false)) #false)


;; Template

;(define (win? state)
;  (if (table-won? state) ... state ...)
;    ... state ...)

;; Code

(define (win? state)
  (if (table-won? state) #true
      #false))


;;; MAIN FUNCTION

(big-bang INITIAL-STATE
  [to-draw draw]
  [on-mouse handle-mouse]
;  [on-key handle-key]
  [stop-when win?]
  )
